<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ramen-collection-Dictionary'>/**
</span> * @class Ramen.collection.Dictionary
 * Represents a set of key value pairs similar to a standard javascript object. However, Dictionary provides additional
 * functionality such as sorting and filtering.
 * @extends Ramen.collection.List
 */
JSoop.define('Ramen.collection.Dictionary', {
    extend: 'Ramen.collection.List',

    isDictionary: true,

    //region Ramen.collection.List Overrides
    //====================================================================================================
    constructor: function () {
        var me = this;

        me.keys = [];
        me.cache = {};

        me.callParent(arguments);
    },

    indexOf: function (item) {
        var me = this;

        if (JSoop.isPrimitive(item)) {
            return me.indexOfKey(item);
        }

        return me.callParent(arguments);
    },

    insertItem: function (item, index, target) {
        var me = this,
            key = me.getKey(item);

        if (target !== me.unfilteredItems) {
            me.keys.splice(index, 0, key);

            me.cache[key] = item;
        }

        return me.callParent(arguments);
    },

    insertUnfilteredItem: function (item, index) {
        var me = this,
            key = me.getKey(item);

        me.unfilteredKeys.splice(index, 0, key);

        return me.callParent(arguments);
    },

    removeAt: function (index) {
        var me = this,
            key = me.keys[index];

        me.keys.splice(index, 1);

        delete me.cache[key];

        me.callParent(arguments);
    },

    onAddBefore: function (dictionary, item, index) {
        var me = this,
            key = me.getKey(item);

        if (me.indexOfKey(key) !== -1 || me.callParent(arguments) === false) {
            return false;
        }
    },

    sort: function (fn) {
        var me = this;

        if (JSoop.isString(fn)) {
            fn = me.createSortFn(fn);
        }

        me.mixins.sortable.prototype.sort.apply(me, [fn]);

        me.ids = [];

        JSoop.each(me.items, function (item) {
            me.ids.push(me.getKey(item));
        });
    },

    afterFilter: function () {
        var me = this;

        me.unfilteredKeys = me.keys.slice();

        me.rebuildKeys();
        me.rebuildCache();

        me.callParent(arguments);
    },

    onRemoveAll: function () {
        var me = this;

        me.keys = [];
        me.unfilteredKeys = [];

        me.cache = {};
    },
    //endregion

    //region New Members
    //====================================================================================================
<span id='Ramen-collection-Dictionary-method-has'>    /**
</span>     * Checks to see whether the dictionary has the specified item.
     * @param {Mixed} item The item to search for
     * @returns {Boolean}
     */
    has: function (item) {
        return this.indexOf(item) !== -1;
    },
<span id='Ramen-collection-Dictionary-method-getKey'>    /**
</span>     * Gets the key of the specified item.
     * @param {Mixed} item
     * @returns {String}
     */
    getKey: function (item) {
        return item.id;
    },
<span id='Ramen-collection-Dictionary-method-indexOfKey'>    /**
</span>     * Gets the index of the specified key.
     * @param {String} key
     * @returns {Number}
     */
    indexOfKey: function (key) {
        var me = this;

        return JSoop.util.Array.indexOf(me.keys, key);
    },
<span id='Ramen-collection-Dictionary-method-get'>    /**
</span>     * Gets the item that matches the specified key.
     * @param {String} key
     * @returns {Mixed}
     */
    get: function (key) {
        return this.cache[key];
    },
<span id='Ramen-collection-Dictionary-method-iterate'>    /**
</span>     * Iterates over the dictionary, executing the given function on each item. If the function returns false, execution
     * will stop.
     * @param {Function} fn The function to execute
     * @param {Mixed} fn.item The current item
     * @param {String} fn.key The current key
     * @param {Object} [scope] The object to scope the functiojn to, defaults to the dictionary.
     */
    iterate: function (fn, scope) {
        var me = this,
            keys = me.keys.slice();

        scope = scope || me;

        me.each(function (item, index) {
            return fn.call(scope, item, keys[index]);
        });
    },
<span id='Ramen-collection-Dictionary-method-createSortFn'>    /**
</span>     * @private
     * @param {Function/String} fn
     * @param {&quot;asc&quot;/&quot;desc&quot;} dir
     * @returns {Function}
     */
    createSortFn: function (fn, dir) {
        var body;

        if (JSoop.isString(fn)) {
            body = [
                'var val1 = item1[&quot;' + fn + '&quot;]',
                '    val2 = item2[&quot;' + fn + '&quot;];',
                'if (val1 ' + ((dir === 'desc')? '&gt;' : '&lt;') + ' val2) {',
                '   return -1;',
                '}',
                'if (val1 ' + ((dir === 'desc')? '&lt;' : '&gt;') + ' val2) {',
                '   return 1;',
                '}',
                'return 0;'
            ];

            fn = new Function('item1', 'item2', body.join('\n'));
        }

        return fn;
    },
<span id='Ramen-collection-Dictionary-method-rebuildCache'>    /**
</span>     * @private
     */
    rebuildCache: function () {
        var me = this;

        me.cache = {};

        me.iterate(function (item, key) {
            me.cache[key] = item;
        });
    },
<span id='Ramen-collection-Dictionary-method-rebuildKeys'>    /**
</span>     * @private
     */
    rebuildKeys: function () {
        var me = this;

        me.keys = [];

        me.each(function (item) {
            me.keys.push(me.getKey(item));
        });
    }
    //endregion
});
</pre>
</body>
</html>
